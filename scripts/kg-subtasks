#!/usr/bin/env python3

from io import StringIO
from subprocess import PIPE
from sys import stdin, stderr
import argparse

from kg.script.programs import *

parser = argparse.ArgumentParser(description='Run against the validator across multiple subtasks and print those which accept.')

parser.add_argument('subs', nargs='+', help='List of subtasks')
parser.add_argument('-q', '--quiet', action='store_true', help=argparse.SUPPRESS)
parser.add_argument('-c', '--command', nargs='+', help='validator command', required=True)

args = parser.parse_args()

get_python3_command(verbose=not args.quiet)
prog = Program.from_args(None, args.command)

def dec(s):
    return s.decode('utf-8').rstrip('\n')

inp = stdin.read()
prog.do_compile()
coll_out = ''
coll_err = ''
for sub in args.subs:
    res = prog.do_run(sub, input=inp.encode('utf-8'), stderr=PIPE, stdout=PIPE, check=False)
    if res.returncode == 0:
        print(sub)
        if res.stdout: coll_out += f"[for subtask {sub}]\n{dec(res.stdout)}\n"
        if res.stderr: coll_err += f"[for subtask {sub}]\n{dec(res.stderr)}\n"

LEN = 1000
if coll_out:
    print('Warning: the command', prog.run, 'outputted something in stdout.\nIt is recommended to not print anything if a validator accepts.', file=stderr)
    print('The following was printed in stdout:', file=stderr)
    print(coll_out[:LEN+3] if len(coll_out) <= LEN+3 else coll_out[:LEN] + '...', file=stderr)
if coll_err:
    print('Warning: the command', prog.run, 'outputted something in stderr.\nIt is recommended to not print anything if a validator accepts.', file=stderr)
    print('The following was printed in stderr:', file=stderr)
    print(coll_err[:LEN+3] if len(coll_err) <= LEN+3 else coll_err[:LEN] + '...', file=stderr)
